#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
holovqa v0.1
holographic MPS variational quantum algorithms 


Created on Mon Oct  5 09:58:45 2020
@author: acpotter
"""
#%% imports
import numpy as np
import cirq
import sympy 

import mps

#%% 
class IsoTensor(object):
    """
        node of an isometric tensor-network, generated by parameterized cirq unitary
        works equally for tensor network state (TNS) or operator (TNO); 
        for TNS: physical register implicitly assumed to start from reference state: |00..0> 
        
        Intention: circuit object intended to be easily adaptable to work equally with cirq, qiskit, etc...
    """
    def __init__(self,qubits,n_params,circuit_format = 'cirq'):
        """
        creates isometric tensor site for list of bond-register sizes
        intputs:
            qubits, list of qubit-registers, object-type depends on circuit_format (e.g. cirq, qiskit, etc...)
                note:
                    number of outgoing legs is automatically the same as incoming ones
                    0th leg denotes the physical leg, 
                    j>1 entries are (incoming) bond-legs
            n_params, int, number of parameters in circuit
            circuit_format, optional (default = 'cirq'), specifies which circuit 
                construction package to use for circuits
        """
        self.n_params = n_params
        self.circuit_format = circuit_format
        self.regdims = len(qubits)
        self.qubits = qubits
        self.tensor_shape = np.append(2**np.array(self.regdims),2**np.array(self.regdims))
        
        if circuit_format == 'cirq':
            ## setup circuit(s) ##
            self.param_names = [sympy.Symbol('x'+str(j)) for j in range(n_params)]
            self.circuit  = cirq.Circuit()
        else:
            raise NotImplementedError('Only cirq implemented')

    def unitary(self,params):
        """
        calls circuit simulator to construct unitary
        returns in shape specified by regdims
        inputs:
            - params, dictionary of {'parameter_names':numerical_values}
        """
        if self.circuit_format == 'cirq':            
            u = self.unitary_cirq(params)
        else:
            raise NotImplementedError('Only cirq implemented')
        return u
    
    def unitary_cirq(self,params):
        """ unitary constructor for cirq-based circuits """
        qubit_order = [q for qreg in self.qubits for q in qreg] # order to return the qubit unitary
        # resolve the symbolic circuit parameters to numerical values
        resolver = cirq.ParamResolver(params)
        resolved_circuit = cirq.resolve_parameters(self.circuit, resolver)   
        u = resolved_circuit.unitary(qubit_order = qubit_order)
        return u.reshape(self.tensor_shape) # reshape as a multi-leg tensor

#%%
class HoloMPS(object):
    """
    Object for: Holographic MPS generated by variational/parameterized circuit 
    """
    
    
    def __init__(self,nphys,nbond,param_names,l_uc=1,circuit_format = 'cirq'):
        """
        inputs:
            nphys, int, number of physical qubits
            nbond, int, number of bond qubits
            l_uc, int, number of sites in unit cell
            param_names,list of sympy symbols, parameterized gate parameters (shared by all tensors)
            circuit_format, str, (default='cirq'), type of circuit editor/simulator used
        """
        self.nphys = nphys # number of physical qubits
        self.nbond = nbond # number of bond qubits
        self.l_uc = l_uc # length of unit cell
        self.param_names = param_names # list of sympy symbols (shared by all tensors)
        self.n_params = len(param_names)
        
        if circuit_format != 'cirq':
            self.qp = [cirq.NamedQubit('p'+str(j)) for j in range(nphys)] # physical qubits
            self.qb = [cirq.NamedQubit('b'+str(j)) for j in range(nbond)] # bond qubits
            self.qubits = [qp,qb]

            # make the MPS/tensor-train -- same qubits used by each tensor
            self.bdry_tensor = IsoTensor(qubits,self.n_params) # tensor for left boundary vector
            self.sites = [IsoTensor(qubits,self.n_params) for j in range(l_uc)]

        else:
            raise NotImplementedError('Only cirq implemented')
    
    ## cpu simulation ##  
    def compute_left_bdry_vector(self,params):
        """
        computes full unitaries for each state (any initial state for physicalqubit)
        inputs:
            params, dictionary of parameters {'name':numerical-value}
        returns:
            bdry_vec, unitary correspond to boundary
            ulist, list of unitaries for tensors in unit cell
        """
        bvec_l = self.bdry_tensor.unitary(params)[0,:,0,0] # boundary circuit tensor 
        return bvec_l
    
    def compute_unitaries(self,params):
        """
        computes full unitaries for each state (any initial state for physicalqubit)
        inputs:
            params, dictionary of parameters {'name':numerical-value}
        returns:
            ulist, list of rank-4 tensors for each site in unit cell
        """
        ulist = [self.sites[j].unitary(params) for j in range(self.l_uc)]
        return ulist
    
    def compute_tensors(self,params):
        """
        computes tensors for fixed initial state of physical qubit = |0>
        inputs:
            params, dictionary of parameters {'name':numerical-value}
        returns:
            tensors, list of rank-3 tensors for each site in unit cell
        """
        tensors = [self.sites[j].unitary(params)[:,:,0,:] for j in range(len(self.tensors))]
        return tensors
    
    ## Convert to other format(s) ##
    def to_tenpy(self,params,infinite=False):
        """
        inputs:
            params, dictionary of parameters {'name':numerical-value}
            infinite, bool (default=false), whether to export to iMPS
            TODO: add any other args needed to specify, symmetries, site-type etc...
        outputs:
            tenpy MPS object created from cirq description
        """
        raise NotImplementedError
        
    def to_mps(self,params):
        """
        converts to custom MPS class object
        inputs:
            params, dictionary of parameters {'name':numerical-value}
        outputs:
            custom MPS object created from cirq description
        """
        tensors = self.compute_tensors(params)
        bvecl = self.compute_compute_left_bdry_vector
        state = mps.MPS(tensors,L=self.L,bdry_vecs=[bvecl,None], rcf = True)
        return state
    
    def to_mpo(self,params):
        """
        converts to custom MPO class object
        inputs:
            params, dictionary of parameters {'name':numerical-value}
        outputs:
            custom MPS object created from cirq description
        """
        tensors = self.compute_unitaries(params)
        bvecl = self.compute_compute_left_bdry_vector
        op = mps.MPO(tensors,L=self.L,bdry_vecs=[bvecl,None], rcf = True)
        return op
        
    ##  correlation function sampling ##
    def sample_correlations(self,options:dict):
        """
        basis: measurement basis for each site
            possible formats: 
                - cirq circuit for physical qubits that maps physical qubits to measurement basis
                - string of 
        possible backends:  
            'tenpy' - uses 
            'qasm' - output qasm script to measure
            
        inputs:
            options: dictionary with entries specifying:
                burn-in length, 
                unit cell length, 
                basis to measure in for each site,
                number of samples to take (could be infinite for cpu-simulations)
                backend: whether to run as 
                
        """
        raise NotImplementedError
      

#%%
#class HoloThermalMPDO(HoloMPS):
#    """
#    Object for: Holographic MPO generated by variational/parameterized circuit 
#    
#    TODO: add capability to 
#    """

#%% test/debug
nphys = 1
nbond = 1
n_params = 2
qp = [cirq.NamedQubit('p'+str(j)) for j in range(nphys)] # physical qubits
qb = [cirq.NamedQubit('b'+str(j)) for j in range(nbond)] # bond qubits
qubits = [qp,qb]




